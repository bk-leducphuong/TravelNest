# RESTFUL API DESIGN RULES (v1.0)

## 1. RESOURCE NAMING
- Resources MUST be nouns.
- Resources MUST be plural.
- Resource names MUST be lowercase.
- Hyphens MAY be used; underscores MUST NOT be used.

VALID:
- /users
- /user-roles

INVALID:
- /getUsers
- /create_user

---

## 2. RESOURCE STRUCTURE
- Root resources MUST be at most 2 levels deep.
- Relationships MUST be expressed using nesting OR query parameters.

VALID:
- /users/{id}/roles
- /users?role=ADMIN

INVALID:
- /companies/{id}/departments/{id}/teams/{id}/users

---

## 3. HTTP METHOD USAGE
- GET MUST NOT modify server state.
- POST MUST create a new resource.
- PUT MUST fully replace a resource.
- PATCH MUST partially update a resource.
- DELETE MUST remove a resource or mark it deleted.

| METHOD | COLLECTION | SINGLE RESOURCE |
|------|-----------|----------------|
| GET | List | Retrieve |
| POST | Create | ❌ |
| PUT | ❌ | Replace |
| PATCH | ❌ | Update |
| DELETE | ❌ | Delete |

---

## 4. HTTP STATUS CODES
- 200 MUST be returned on successful GET or PATCH.
- 201 MUST be returned on successful POST.
- 204 MUST be returned on successful DELETE.
- 400 MUST be returned for malformed requests.
- 401 MUST be returned for unauthenticated requests.
- 403 MUST be returned for unauthorized requests.
- 404 MUST be returned if resource does not exist.
- 409 MUST be returned for conflicts.
- 500 MUST NOT expose internal error details.

---

## 5. REQUEST FORMAT
- Content-Type MUST be application/json.
- Accept MUST be application/json.
- Request bodies MUST be validated using a schema.
- Unknown fields MUST be rejected.

---

## 6. RESPONSE FORMAT
- Responses MUST be JSON.
- Root response MUST NOT include raw arrays.
- Data MUST be wrapped inside a "data" field.

VALID:
{
  "data": {...}
}

INVALID:
[
  {...}
]

---

## 7. ERROR RESPONSE FORMAT
- Errors MUST be returned using a single "error" object.
- Error responses MUST include:
  - code
  - message
- Validation errors MUST include field-level errors.

FORMAT:
{
  "error": {
    "code": "ERROR_CODE",
    "message": "Human readable message",
    "fields": {}
  }
}

---

## 8. USER RESOURCE SCHEMA
- id MUST be a UUID string.
- email MUST be unique and valid.
- password MUST NEVER be returned.
- createdAt and updatedAt MUST be ISO-8601 strings.

---

## 9. PAGINATION
- Pagination MUST be supported for collection endpoints.
- Default limit MUST be 20.
- Maximum limit MUST NOT exceed 100.

FORMAT:
{
  "data": [],
  "meta": {
    "page": 1,
    "limit": 20,
    "total": 0
  }
}

---

## 10. FILTERING & SORTING
- Filtering MUST use query parameters.
- Sorting MUST use "sort=field,order".
- order MUST be "asc" or "desc".

VALID:
- /users?role=ADMIN&sort=createdAt,desc

---

## 11. VERSIONING
- API MUST be versioned in URL.
- Version prefix MUST be "/api/v{number}".

VALID:
- /api/v1/users

---

## 12. AUTHENTICATION
- Authentication MUST use Bearer token.
- Authorization header MUST follow format:
  Authorization: Bearer <token>

---

## 13. AUTHORIZATION
- Role-based access control MUST be enforced.
- Users MUST NOT access resources they do not own unless authorized.

---

## 14. IDEMPOTENCY
- GET, PUT, DELETE MUST be idempotent.
- POST SHOULD support Idempotency-Key header.

---

## 15. SECURITY
- HTTPS MUST be enforced.
- Input MUST be sanitized.
- Rate limiting MUST be applied.
- Stack traces MUST NOT be returned.

---

## 16. SOFT DELETE
- Resources SHOULD support soft deletion.
- deletedAt MUST be null or ISO-8601 timestamp.
- Soft-deleted resources MUST NOT appear in list results.

---

## 17. LOGGING
- Each request MUST have a correlation ID.
- Correlation ID header name MUST be "X-Request-Id".
- Logs MUST include:
  - method
  - path
  - status code
  - execution time
  - user id (if available)

---

## 18. DOCUMENTATION
- OpenAPI specification MUST exist.
- Every endpoint MUST define:
  - request schema
  - response schema
  - error responses

---

## 19. HEALTH CHECK
- Service MUST expose:
  GET /health
- Health endpoint MUST NOT require authentication.

---

## 20. DEPRECATED BEHAVIOR
- Verb-based URLs MUST NOT be used.
- Business actions MUST NOT be exposed as endpoints.
- Database models MUST NOT be returned directly.

---

Express REST API – Architecture & Rules (v1)
1. Architecture Layers (Strict)
Route → Validation → Controller → Service → Repository → Sequelize Model → DB

Responsibilities

Route: URL + middleware wiring only

Validation (Joi): request shape only

Controller: HTTP ↔ service mapping

Service: business logic, authorization, transactions

Repository: Sequelize queries only

Model: schema + DB-level constraints

❌ No layer may skip another
❌ Controllers/services must NOT import Sequelize models

2. Folder Structure (Required)
src/
 ├── routes/
 ├── controllers/
 ├── services/
 ├── repositories/
 ├── models/
 ├── validators/
 ├── middlewares/
 └── utils/

3. Controllers (Rules)

Must be async

Must be wrapped with asyncHandler

Must NOT contain:

try/catch

business logic

Sequelize usage

Must use response helpers only

✅ Controllers never throw raw errors

4. Services (Rules)

Contain all business logic

Handle authorization & ownership checks

Start and manage transactions

Must throw ApiError (or predefined errors)

Must NOT:

access req / res

return HTTP responses

catch errors unless rethrowing

✅ Services are the only place to decide why an operation fails

5. Repositories (Rules)

Only layer allowed to use Sequelize models

Encapsulate all queries, includes, pagination

No business rules

Accept transaction via options

❌ No HTTP logic
❌ No validation logic

6. Sequelize Models (Rules)

Define schema, relations, DB constraints

Use underscored, paranoid when needed

No business logic in hooks

No request validation

❌ No service logic
❌ No authorization logic

7. Validation Layer (Joi)

Validation happens before controller

Validate params, query, body, headers

Use:

abortEarly: false

stripUnknown: true

Validation errors → ApiError(400, VALIDATION_ERROR)

❌ No Joi in services or controllers

8. Error Handling (Mandatory)

Use a single ApiError class

Services throw errors

Controllers never catch

One global error middleware (last)

Error Response Format
{
  "success": false,
  "error": {
    "code": "ERROR_CODE",
    "message": "Human readable",
    "details": {}
  }
}

9. Success Response Format (Mandatory)
{
  "success": true,
  "data": {},
  "meta": {}
}


Use response helpers (ok, created, noContent)

Never return errors with HTTP 200

10. Sequelize Error Mapping

Sequelize errors must be mapped centrally:

UniqueConstraintError → 409

ValidationError → 400

Services must not depend on Sequelize error types

11. HTTP Status Codes (Strict)

200 → OK

201 → Created

204 → No Content

400 → Validation / bad request

401 → Unauthorized

403 → Forbidden

404 → Not found

409 → Conflict

500 → Internal error

12. Absolute Prohibitions ❌

No res.json() outside response helpers

No throw new Error()

No Sequelize in controllers/services

No validation in controllers/services

No business logic in repositories/models

No sequelize.sync() in production

13. Golden Rule

Controllers translate, services decide, repositories fetch.

## END OF RULES

